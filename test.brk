
(setq verbose t)
(setq fatal t)

(defun make-test (env pred-form &keys
                  form-string 
                  position position-string 
                  verbose-message 
                  (fatal None) fatal-message
                  warn-message)
  (unless form-string
    (setq form-string (str pred-form)))
  (unless position
    (setq position (env.getALoc pred-form)))
  (unless position-string
    (destructuring-bind 
          (lineno colno) position
      (setq position-string (x!format "%d" lineno))))
  (when (is fatal None)
    (setq fatal (item (globals) "fatal")))
  `(progn
     ,(when verbose
            `(say ,(or verbose-message
                       (x!format "testing %s %s" position-string form-string))))
     (unless ,pred-form
       ,(if fatal
            `(error ,(or fatal-message
                        (x!format "test %s %s failed" position-string form-string)))
            `(say ,(or warn-message
                      (x!format "warning: %s test %s failed" position-string form-string)))))))


(defmacro test  (&env env form &keys (fatal None))
  (make-test env form :fatal fatal))

(defmacro deftest (name lambda-list &body body)
  (with-gensyms (env args)
    `(defmacro ,name (&env ,env &rest-clist ,args)
       (make-test ,env (destructuring-bind 
                             ,lambda-list ,args
                         ,body)
                  :form-string (str (cons ',name ,args))
          :position ((a ,env getALoc))))))

(deftest teq (lop rop)
  `(eq ,lop ,rop))
(deftest tis (lop rop)
  `(is ,lop ,rop))
(deftest tnot (op)
  `(not ,op))
(deftest tneq (lop rop)
  `(neq ,lop ,rop))
(deftest tinstance (tp form)
  `(isinstance ,form ,tp))

(test (is 'A 'A))

;; symbols
(test (symbolp (symbol "stuff")))
(test (symbolp 'a))
(tis 'a (symbol "a"))
(teq 'a (symbol "a"))
(tnot (is (symbol "a")
          (symbol "b")))
(tneq (symbol "a")
      (symbol "b"))


;; cons
(tnot nil)
(test (consp nil))
(test (consp '()))
(test (consp '(1 2 3)))
(test (consp (cons 1 2)))
(test (consp (clist 1 2)))
(tis nil '())
(teq nil nil)
(teq (clist 1 2) '(1 2))

;; lexical scoping
(deftest ta (op)
  `(eq a ,op))
(setq a "global")
(ta "global")
(let ((a 3))
  (let ((a 5))
    (ta 5))
  (ta 3))
(ta "global")

(let ((a 3))
  (let ((set (lambda (op) (setq a op))))
    (ta 3)
    (set 5)
    (ta 5))
  (ta 5))
(ta "global")

(let ((a 3))
  (let* ((a 7)
         (set (lambda (op) (setq a op))))
    (ta 7)
    (set 5)
    (ta 5))
  (ta 3))
(ta "global")
(delitem (globals) "a")
(delitem (globals) "ta")

;;arithmetic
(teq (+ 1 2 3 4 5) 15)
(teq (* 1 2 3 4 5) 120)
(teq (* 0 1 2 3 4 5) 0)
(teq (* 0 1 2 3 4 0) 0)
(tinstance int (+ 1 2 3 4 5))
(tinstance int (* 1 2 3 4 5))
(teq (- 1) -1)
(teq (modulo 10 9) 1)
(tinstance int (modulo 10 9))

;; comparisions
(test (== 'a 'a 'a 'a))
(test (not (== 'a 'a 'b 'a)))
(test (< 1 2 3 4 5 6))
(test (not (< 1 2 3 3 4 5 6)))
(test (<= 1 2 3 3 4 5 6))
(test (not (<= 1 2 3 2 4 5 6)))

;; destructuring-bind
(destructuring-bind (a b c)
    '(1 2 3)
  (teq a '1)
  (teq b '2)
  (teq c '3))

(let ((a 3))
  (teq a 3)
  (destructuring-bind (a b c)
      '(1 2 3)
    (teq a '1)
    (teq b '2)
    (teq c '3))
  (teq a 3))

(destructuring-bind (a b c &rest rest)
    '(1 2 3 4 5)
  (teq a 1)
  (teq b 2)
  (teq c 3)
  (tinstance tuple rest)
  (teq rest (tuple (clist 4 5))))

(destructuring-bind (a b c &rest-clist rest)
    '(1 2 3 4 5)
  (teq a 1)
  (teq b 2)
  (teq c 3)
  (tinstance cons rest)
  (teq rest (clist 4 5)))

(destructuring-bind (&rest-clist rest)
    '(1 2 3 4 5)
  (tinstance cons rest)
  (teq rest (clist 1 2 3 4 5)))

(destructuring-bind (a b c &body rest)
    '(1 2 3 4 5)
  (teq a 1)
  (teq b 2)
  (teq c 3)
  (tinstance cons rest)
  (teq rest `(progn 4 5)))

(destructuring-bind (a (b0 b1 b2) c)
    '(1 (2 3 4) 5)
  (teq a 1)
  (teq b0 2)
  (teq b1 3)
  (teq b2 4)
  (teq c 5))

(destructuring-bind (a &keys b)
    '(1 2)
  (teq a 1)
  (teq b 2))

(destructuring-bind (a &keys b)
    '(1)
  (teq a 1)
  (tis b nil))

(destructuring-bind (a &keys b c d)
    '(1 2 3 4)
  (teq a 1)
  (teq b 2)
  (teq c 3)
  (teq d 4))

(destructuring-bind (a &keys b c d)
    '(1 :d 2 :c 3 :b 4)
  (teq a 1)
  (teq b 4)
  (teq c 3)
  (teq d 2))

(destructuring-bind (a &keys (b 100))
    '(1 2)
  (teq a 1)
  (teq b 2))

(destructuring-bind (a &keys (b 100))
    '(1)
  (teq a 1)
  (teq b 100))

(destructuring-bind (a &keys (b (* 10 a)))
    '(1)
  (teq a 1)
  (teq b 10))

(destructuring-bind (a &keys (b (* 10 a))
                       &rest-clist rest)
    '(1 2 3)
  (teq a 1)
  (teq b 2)
  (teq rest '(3)))

(destructuring-bind (a &keys (b (* 10 a))
                       &rest-clist rest)
    '(1)
  (teq a 1)
  (teq b 10)
  (teq rest '()))

(destructuring-bind (a &keys 
                       (b (* 10 a))
                       (c (* 10 b))
                       (d (* 10 c)))
    
    '(1)
  (teq a 1)
  (teq b 10)
  (teq c 100)
  (teq d 1000))

(destructuring-bind (a &keys 
                       (b (* 10 a))
                       (c (* 10 b))
                       (d (* 10 c)))
    
    '(1 5)
  (teq a 1)
  (teq b 5)
  (teq c 50)
  (teq d 500))


(destructuring-bind (a &keys 
                       (b (* 10 a))
                       (c (* 10 b))
                       (d (* 10 c)))
    
    '(1 :b 5)
  (teq a 1)
  (teq b 5)
  (teq c 50)
  (teq d 500))

(destructuring-bind (a &keys 
                       (b (* 10 a))
                       (c (* 10 b))
                       (d (* 10 c)))
    
    '(1 :c 5)
  (teq a 1)
  (teq b 10)
  (teq c 5)
  (teq d 50))

(destructuring-bind (a &keys 
                       (b (* 10 a))
                       (c (* 10 b))
                       (d (* 10 c)))
    
    '(1 :c 5 :d 8 :b 9)
  (teq a 1)
  (teq b 9)
  (teq c 5)
  (teq d 8))

(destructuring-bind (a (&keys b c) &body body)
    '(10 (1 3) 5 6 7)
  (teq a 10)
  (teq b 1)
  (teq c 3)
  (teq body '(progn 5 6 7)))

;; obj
(let ((o (obj :a 1 :b 2)))
  (teq o.a 1)
  (teq o.b 2)
  (teq (sorted (vars o))
       (list '("a" "b"))))

;; setf
(let ((o (obj :a 3)))
  (setf o.a 5)
  (teq o.a 5)
  (teq (setf o.a 7) 7)
  (teq o.a 7))

(let ((l (clist 1 2 3)))
  (teq l '(1 2 3))
  (setf (car l) 6)
  (teq l '(6 2 3))
  (setf (cdr l) (clist 5 8))
  (teq l '(6 5 8))
  (setf (cdr (cdr l)) (clist 7 0))
  (teq l '(6 5 7 0)))

(let ((d (dict)))
  (teq d (dict))
  (setf (item d 1) 2)
  (teq (item d 1) 2)
  (teq (setf (item d 'a) 8) 8)
  (teq (item d 'a) 8)
  (teq (set d)
       (set '(1 a))))

(let ((o (obj :a nil)))
  (teq o.a nil)
  (push 3 o.a)
  (teq o.a '(3))
  (push 'y o.a)  
  (teq o.a '(y 3))
  (push 50 o.a)  
  (teq o.a '(50 y 3))
  (teq (pop o.a) 50)
  (teq o.a '(y 3))  
  (teq (pop o.a) 'y)
  (teq o.a '(3))  
  (teq (pop o.a) 3)
  (teq o.a nil))

(let ((o (obj :a 0)))
  (teq o.a 0)
  (incf o.a)
  (teq o.a 1)
  (incf o.a 5)
  (teq o.a 6)
  (decf o.a)
  (teq o.a 5)
  (decf o.a 2)
  (teq o.a 3))



